const pathmaker={start(ctx){ctx.beginPath()},end(ctx){ctx.closePath()},points(ctx,pts){if(pts.length<2)return!1;ctx.moveTo(pts[0].x,pts[0].y);for(let{x:x,y:y}of pts)ctx.lineTo(x,y)},polygon(ctx,x,y,r,a,s){let eachangle=360/s,line=[];for(let i=0;i<=s;i++)line.push(getSatelliteXY(x,y,degreesToRadians(a+eachangle*i),r));pathmaker.points(ctx,line)},circle(ctx,x,y,r,a1=0,a2=2*Math.PI,a3){pathmaker.arc(ctx,x,y,r,a1,a2,a3)},arc(ctx,x,y,r,a1,a2,a3){ctx.arc(x,y,r,a1,a2,a3)},rect(ctx,x,y,w,h){pathmaker.points(ctx,[{x:x,y:y},{x:x+w,y:y},{x:x+w,y:y+h},{x:x,y:y+h},{x:x,y:y}])},pie(ctx,x,y,or,ir,sa,ea,ad){pathmaker.arc(ctx,x,y,or,sa,ea+sa,!ad),pathmaker.arc(ctx,x,y,ir,ea+sa,sa,ad)},roundRect(ctx,x,y,w,h,r){r=void 0===r?0:"number"==typeof r?{tl:r,tr:r,br:r,bl:r}:Object.assign({tl:0,tr:0,br:0,bl:0},r),ctx.moveTo(x+r.tl,y),ctx.lineTo(x+w-r.tr,y),ctx.quadraticCurveTo(x+w,y,x+w,y+r.tr),ctx.lineTo(x+w,y+h-r.br),ctx.quadraticCurveTo(x+w,y+h,x+w-r.br,y+h),ctx.lineTo(x+r.bl,y+h),ctx.quadraticCurveTo(x,y+h,x,y+h-r.bl),ctx.lineTo(x,y+r.tl),ctx.quadraticCurveTo(x,y,x+r.tl,y)}},makePath=(ctx,paths,close=!0)=>{pathmaker.start(ctx);for(let o of paths)pathmaker[o.splice(0,1,ctx)[0]].apply(null,o);close&&pathmaker.end(ctx)},strokeIt=(ctx,options)=>{options&&options.lineWidth&&Object.assign(ctx,options).stroke()},fillIt=(ctx,options)=>{options&&options.fillStyle&&Object.assign(ctx,options).fill()},drawCircle=(ctx,x,y,r,options)=>{makePath(ctx,[["circle",x,y,r]]),fillIt(ctx,options),strokeIt(ctx,options)},drawRect=(ctx,x,y,w,h,options,c=!1)=>{makePath(ctx,[["rect",c?x-.5*w:x,c?y-.5*h:y,w,h]]),fillIt(ctx,options),strokeIt(ctx,options)},drawPolygon=(ctx,x,y,r,a,s,options)=>{makePath(ctx,[["polygon",x,y,r,a,s]]),fillIt(ctx,options),strokeIt(ctx,options)},drawRandomRect=(ctx,x,y,w,h,options)=>{options.fillStyle=`rgba(\n      ${rand(120,250)},\n      ${rand(120,250)},\n      ${rand(120,250)},\n      ${Object.assign({opacity:.7},options).opacity}\n      )`,drawRect(ctx,x,y,w,h,options)},drawSegment=(ctx,x1,y1,x2,y2,options)=>{makePath(ctx,[["points",[{x:x1,y:y1},{x:x2,y:y2}]]]),strokeIt(ctx,options)},drawLine=(ctx,line,options,close=!1)=>{makePath(ctx,[["points",line]],close),strokeIt(ctx,options),fillIt(ctx,options)},drawText=(ctx,x,y,text,options)=>{ctx=Object.assign(ctx,options),options.lineWidth&&ctx.strokeText(text,x,y),options.fillStyle&&ctx.fillText(text,x,y)},drawParagraph=(ctx,x,y,text,lineHeight,options)=>{var ps=text.split(/\n/);for(let i in ps)drawText(ctx,x,y+lineHeight*i,ps[i],options)},drawLabel=(ctx,text,x,y,options)=>{(ctx=Object.assign(ctx,options)).globalCompositeOperation="destination-out",ctx.strokeText(text,x,y),ctx.globalCompositeOperation="source-over",ctx.fillText(text,x,y)},drawPie=(ctx,x,y,outerRadius,innerRadius,startangle,endangle,additive,options)=>{makePath(ctx,[["pie",x,y,outerRadius,innerRadius,startangle,endangle,additive]]),fillIt(ctx,options),strokeIt(ctx,options)},drawRoundRect=(ctx,x,y,w,h,r,options)=>{makePath(ctx,[["roundRect",x,y,w,h,r]]),strokeIt(ctx,options),fillIt(ctx,options)},drawGradient=(ctx,direction,stops,position)=>{let grd=ctx.createLinearGradient.apply(ctx,direction);for(let o of stops)grd.addColorStop.apply(grd,o);ctx.fillStyle=grd,ctx.fillRect.apply(ctx,position)},drawPoints=(ctx,line,radius,options)=>{pathmaker.start(ctx);for(let{x:x,y:y}of line)ctx.moveTo(x,y),pathmaker.circle(ctx,x,y,radius);strokeIt(ctx,options),fillIt(ctx,options)},drawGrid=(ctx,x,y,w,h,rows,cols,options)=>{pathmaker.start(ctx);for(let i=0;i<=rows;i++)pathmaker.points(ctx,[{x:x,y:h*(i/rows)+y},{x:x+w,y:h*(i/rows)+y}]);for(let i=0;i<=cols;i++)pathmaker.points(ctx,[{x:w*(i/cols)+x,y:y},{x:w*(i/cols)+x,y:y+h}]);pathmaker.end(ctx),strokeIt(ctx,options)},drawLineGraph=(ctx,x,y,w,h,line,row,col,r,options=[{strokeStyle:"#ddd",lineWidth:2,lineJoin:"round",lineCap:"round"},{strokeStyle:"black",lineWidth:2,lineJoin:"round",lineCap:"round"},{fillStyle:"white",strokeStyle:"black",lineWidth:2}])=>{drawGrid(ctx,x,y,w,h,row,col,options[0]),drawLine(ctx,line,options[1]),drawPoints(ctx,line,r,options[2])},lineFromValues=(x,y,w,h,min,max,v)=>v.map((o,i)=>({x:toward(x,x+w)(i/(v.length-1)),y:mapRange(y+h,y)(min,max)(o)})),rotateAndDo=(ctx,angleInRad,positionX,positionY,callback)=>{ctx.translate(positionX,positionY),ctx.rotate(angleInRad),callback(),ctx.rotate(-angleInRad),ctx.translate(-positionX,-positionY)},translateScaleRotate=(ctx,x,y,sx,sy,r,fn)=>{ctx.save(),ctx.translate(x,y),ctx.scale(sx,sy),ctx.rotate(r),fn(),ctx.restore()},translateScale=(ctx,x,y,sx,sy,fn)=>{ctx.save(),ctx.translate(x,y),ctx.scale(sx,sy),fn(),ctx.restore()},drawableImage=url=>{let loaded=!1,i=new Image;i.onload=(()=>loaded=!0),i.src=url;const drawI=function(ctx,x,y,w,h){loaded?ctx.drawImage(i,x,y,w,h):setTimeout(drawI,10)};return drawI},storeImage=(cvs,w,h)=>{let i=new Image;return i.src=cvs.toDataURL(),i},drawImageTSR=(ctx,img,x,y,w,h,sx,sy,r)=>{translateScaleRotate(ctx,x,y,sx,sy,r,function(){ctx.drawImage(img,.5*-w,.5*-h,w,h)})},pathtransform=function(ctx){this.ctx=ctx,ctx.save()};pathtransform.prototype.scale=function(x,y){return this.s={x:x,y:void 0===y?x:y},this.ctx.scale(this.s.x,this.s.y),this},pathtransform.prototype.unscale=function(){return this.ctx.scale(-this.s.x,-this.s.y),this},pathtransform.prototype.translate=function(x,y){return this.t={x:x,y:y},this.ctx.translate(this.t.x,this.t.y),this},pathtransform.prototype.untranslate=function(){return this.ctx.translate(-this.t.x,-this.t.y),this},pathtransform.prototype.rotate=function(r){return this.r=r,this.ctx.rotate(this.r),this},pathtransform.prototype.unrotate=function(){return this.ctx.rotate(-this.r),this},pathtransform.prototype.do=function(fn,...args){return fn(this.ctx,...args),this},pathtransform.prototype.restore=function(){return this.ctx.restore(),this},pathtransform.prototype.save=function(){return this.ctx.save(),this};