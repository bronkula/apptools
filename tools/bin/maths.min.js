const degreesToRadians=a=>a*Math.PI/180,radiansToDegrees=a=>180*a/Math.PI,angleFromPoints=(x1,y1,x2,y2)=>Math.atan2(y2-y1,x2-x1),pointDistance=(x1,y1,x2,y2)=>Math.hypot(x1-x2,y1-y2),angleFromSides=(a,b,c)=>Math.acos((c*c+a*a-b*b)/(2*c*a)),rand=(n,x)=>Math.round(Math.random()*(x-n))+n,circumference=r=>2*Math.PI*r,xy=(x,y)=>({x:x,y:y}),vxs=(x0,y0,x1,y1)=>x0*y1-x1*y0,bounce=(n,x)=>(p,s)=>p>=x||p<=n?-s:s,bounceX=a=>Math.sign(a)*unsignHalfRadian(-signHalfRadian(Math.abs(signRadian(a)))),bounceY=a=>-signRadian(a),ratio=(min,max)=>n=>n*min/max,nudge=(o,p,n)=>p*n+o,clamp=(min,max)=>n=>n>max?max:n<min?min:n,unsignNumber=max=>n=>n<0?n+max:n,unsignRadian=unsignNumber(2*Math.PI),unsignHalfRadian=unsignNumber(Math.PI),unsignDegree=unsignNumber(360),signNumber=max=>n=>n>.5*max?n-max:n<-.5*max?n+max:n,signRadian=signNumber(2*Math.PI),signHalfRadian=signNumber(Math.PI),signDegree=signNumber(360),wrapNumber=max=>{const t=unsignNumber(max),s=signNumber(max);return n=>t(s(n))},within=(min,max)=>{const r=max-min+1,t=unsignNumber(r),s=signNumber(r);return n=>t(s(n-min))+min},partof=(min,max)=>n=>(n-min)/(max-min),partofCircle=partof(0,360),toward=(min,max)=>n=>n*(max-min)+min,mapRange=(min,max)=>{const t=toward(min,max);return(min,max)=>{const p=partof(min,max);return n=>t(p(n))}},roundTo=(n,x)=>{if(x<1){var m=(""+x).split("."),m2=Math.pow(10,m[1].length);n*=m2,x*=m2}let r=x*Math.round(n/x);return m2?r/m2:r},positionToward=(x1,y1,x2,y2,p)=>xy(toward(x1,x2)(p),toward(y1,y2)(p)),getSatelliteXY=(x,y,a,d)=>({x:x+Math.cos(a)*d,y:y+Math.sin(a)*d}),overlap=(a1,a2,b1,b2)=>Math.min(a1,a2)<=Math.max(b1,b2)&&Math.min(b1,b2)<=Math.max(a1,a2),intersectBox=(x0,y0,x1,y1,x2,y2,x3,y3)=>overlap(x0,x1,x2,x3)&&overlap(y0,y1,y2,y3),pointSide=(px,py,x0,y0,x1,y1)=>vxs(x1-x0,y1-y0,px-x0,py-y0),intersect=(x0,y0,x1,y1,x2,y2,x3,y3)=>xy(vxs(vxs(x0,y0,x1,y1),x0-x1,vxs(x2,y2,x3,y3),x2-x3)/vxs(x0-x1,y0-y1,x2-x3,y2-y3),vxs(vxs(x0,y0,x1,y1),y0-y1,vxs(x2,y2,x3,y3),y2-y3)/vxs(x0-x1,y0-y1,x2-x3,y2-y3)),isIntersect=(x0,y0,x1,y1,x2,y2,x3,y3)=>IntersectBox(x0,y0,x1,y1,x2,y2,x3,y3)&&2!=Math.abs(PointSide(x2,y2,x0,y0,x1,y1)+PointSide(x3,y3,x0,y0,x1,y1))&&2!=Math.abs(PointSide(x0,y0,x2,y2,x3,y3)+PointSide(x1,y1,x2,y2,x3,y3)),pointInRect=(x1,y1,x2,y2)=>(px,py)=>px>=x1&&px<=x2&&py>=y1&&py<=y2,inRange=(a,b)=>n=>a<=n&&b>=n,pointInArc=(px,py,ax,ay,ir,or,as,ae)=>inRange(as,ae)(Math.atan2(ay-py,ax-px))&&inRange(ir,or)(Math.hypot(px-ax,py-ay)),rectInRect=(x1,y1,x2,y2)=>{const r=pointInRect(x1,y1,x2,y2);return(x1,y1,x2,y2)=>r(x1,y1)&&r(x2,y2)},circleCollission=(x1,y1,r1,x2,y2,r2)=>pointDistance(x1,y1,x2,y2)<r1+r2;