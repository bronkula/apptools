const pathmaker={start(ctx){ctx.beginPath()},end(ctx){ctx.closePath()},points(ctx,pts){if(pts.length<2)return!1;ctx.moveTo(pts[0].x,pts[0].y);for(let{x:x,y:y}of pts)ctx.lineTo(x,y)},polygon(ctx,x,y,r,a,s){let eachangle=360/s,line=[];for(let i=0;i<=s;i++)line.push(getSatelliteXY(x,y,degreesToRadians(a+eachangle*i),r));pathmaker.points(ctx,line)},circle(ctx,x,y,r,a1=0,a2=2*Math.PI,a3){pathmaker.arc(ctx,x,y,r,a1,a2,a3)},arc(ctx,x,y,r,a1,a2,a3){ctx.arc(x,y,r,a1,a2,a3)},rect(ctx,x,y,w,h){pathmaker.points(ctx,[{x:x,y:y},{x:x+w,y:y},{x:x+w,y:y+h},{x:x,y:y+h},{x:x,y:y}])},pie(ctx,x,y,or,ir,sa,ea,ad){pathmaker.arc(ctx,x,y,or,sa,ea+sa,!ad),pathmaker.arc(ctx,x,y,ir,ea+sa,sa,ad)},roundRect(ctx,x,y,w,h,r){r=void 0===r?0:"number"==typeof r?{tl:r,tr:r,br:r,bl:r}:Object.assign({tl:0,tr:0,br:0,bl:0},r),ctx.moveTo(x+r.tl,y),ctx.lineTo(x+w-r.tr,y),ctx.quadraticCurveTo(x+w,y,x+w,y+r.tr),ctx.lineTo(x+w,y+h-r.br),ctx.quadraticCurveTo(x+w,y+h,x+w-r.br,y+h),ctx.lineTo(x+r.bl,y+h),ctx.quadraticCurveTo(x,y+h,x,y+h-r.bl),ctx.lineTo(x,y+r.tl),ctx.quadraticCurveTo(x,y,x+r.tl,y)}},makePath=(ctx,paths,close=!0)=>{pathmaker.start(ctx);for(let o of paths)pathmaker[o.splice(0,1,ctx)[0]].apply(null,o);close&&pathmaker.end(ctx)},strokeIt=(ctx,options)=>{options&&options.lineWidth&&Object.assign(ctx,options).stroke()},fillIt=(ctx,options)=>{options&&options.fillStyle&&Object.assign(ctx,options).fill()},drawCircle=(ctx,x,y,r,options)=>{makePath(ctx,[["circle",x,y,r]]),fillIt(ctx,options),strokeIt(ctx,options)},drawRect=(ctx,x,y,w,h,options)=>{makePath(ctx,[["rect",x,y,w,h]]),fillIt(ctx,options),strokeIt(ctx,options)},drawPolygon=(ctx,x,y,r,a,s,options)=>{makePath(ctx,[["polygon",x,y,r,a,s]]),fillIt(ctx,options),strokeIt(ctx,options)},drawRandomRect=(ctx,x,y,w,h,options)=>{options.fillStyle=`rgba(\n      ${rand(120,250)},\n      ${rand(120,250)},\n      ${rand(120,250)},\n      ${Object.assign({opacity:.7},options).opacity}\n      )`,drawRect(ctx,x,y,w,h,options)},drawSegment=(ctx,x1,y1,x2,y2,options)=>{makePath(ctx,[["points",[{x:x1,y:y1},{x:x2,y:y2}]]]),strokeIt(ctx,options)},drawLine=(ctx,line,options,close=!1)=>{makePath(ctx,[["points",line]],close),strokeIt(ctx,options),fillIt(ctx,options)},drawText=(ctx,x,y,text,options)=>{ctx=Object.assign(ctx,options),options.lineWidth&&ctx.strokeText(text,x,y),options.fillStyle&&ctx.fillText(text,x,y)},drawParagraph=(ctx,x,y,text,lineHeight,options)=>{var ps=text.split(/\n/);for(let i in ps)drawText(ctx,x,y+lineHeight*i,ps[i],options)},drawLabel=(ctx,text,x,y,options)=>{(ctx=Object.assign(ctx,options)).globalCompositeOperation="destination-out",ctx.strokeText(text,x,y),ctx.globalCompositeOperation="source-over",ctx.fillText(text,x,y)},drawPie=(ctx,x,y,outerRadius,innerRadius,startangle,endangle,additive,options)=>{makePath(ctx,[["pie",x,y,outerRadius,innerRadius,startangle,endangle,additive]]),fillIt(ctx,options),strokeIt(ctx,options)},drawRoundRect=(ctx,x,y,w,h,r,options)=>{makePath(ctx,[["roundRect",x,y,w,h,r]]),strokeIt(ctx,options),fillIt(ctx,options)},drawGradient=(ctx,direction,stops,position)=>{let grd=ctx.createLinearGradient.apply(ctx,direction);for(let o of stops)grd.addColorStop.apply(grd,o);ctx.fillStyle=grd,ctx.fillRect.apply(ctx,position)},drawPoints=(ctx,line,radius,options)=>{pathmaker.start(ctx);for(let{x:x,y:y}of line)ctx.moveTo(x,y),pathmaker.circle(ctx,x,y,radius);strokeIt(ctx,options),fillIt(ctx,options)},drawGrid=(ctx,x,y,w,h,rows,cols,options)=>{pathmaker.start(ctx);for(let i=0;i<=rows;i++)pathmaker.points(ctx,[{x:x,y:h*(i/rows)+y},{x:x+w,y:h*(i/rows)+y}]);for(let i=0;i<=cols;i++)pathmaker.points(ctx,[{x:w*(i/cols)+x,y:y},{x:w*(i/cols)+x,y:y+h}]);pathmaker.end(ctx),strokeIt(ctx,options)},drawLineGraph=(ctx,x,y,w,h,line,row,col,r,options=[{strokeStyle:"#ddd",lineWidth:2,lineJoin:"round",lineCap:"round"},{strokeStyle:"black",lineWidth:2,lineJoin:"round",lineCap:"round"},{fillStyle:"white",strokeStyle:"black",lineWidth:2}])=>{drawGrid(ctx,x,y,w,h,row,col,options[0]),drawLine(ctx,line,options[1]),drawPoints(ctx,line,r,options[2])},rotateAndDo=(ctx,angleInRad,positionX,positionY,callback)=>{ctx.translate(positionX,positionY),ctx.rotate(angleInRad),callback(),ctx.rotate(-angleInRad),ctx.translate(-positionX,-positionY)},translateScaleRotate=(ctx,x,y,sx,sy,r,fn)=>{ctx.save(),ctx.translate(x,y),ctx.scale(sx,sy),ctx.rotate(r),fn(),ctx.restore()},translateScale=(ctx,x,y,sx,sy,fn)=>{ctx.save(),ctx.translate(x,y),ctx.scale(sx,sy),fn(),ctx.restore()},drawableImage=url=>{let loaded=!1,i=new Image;i.onload=(()=>loaded=!0),i.src=url;const drawI=function(ctx,x,y,w,h){loaded?ctx.drawImage(i,x,y,w,h):setTimeout(drawI,10)};return drawI},storeImage=(cvs,w,h)=>{let i=new Image;return i.src=cvs.toDataURL(),i},drawImageTSR=(ctx,img,x,y,w,h,sx,sy,r)=>{translateScaleRotate(ctx,x,y,sx,sy,r,function(){ctx.drawImage(img,.5*-w,.5*-h,w,h)})},pathtransform=function(ctx){this.ctx=ctx,ctx.save()};pathtransform.prototype.scale=function(x,y){return this.s={x:x,y:void 0===y?x:y},this.ctx.scale(this.s.x,this.s.y),this},pathtransform.prototype.unscale=function(){return this.ctx.scale(-this.s.x,-this.s.y),this},pathtransform.prototype.translate=function(x,y){return this.t={x:x,y:y},this.ctx.translate(this.t.x,this.t.y),this},pathtransform.prototype.untranslate=function(){return this.ctx.translate(-this.t.x,-this.t.y),this},pathtransform.prototype.rotate=function(r){return this.r=r,this.ctx.rotate(this.r),this},pathtransform.prototype.unrotate=function(){return this.ctx.rotate(-this.r),this},pathtransform.prototype.do=function(fn,...args){return fn(this.ctx,...args),this},pathtransform.prototype.restore=function(){return this.ctx.restore(),this},pathtransform.prototype.save=function(){return this.ctx.save(),this};const RGB=function(r,g,b){this.r=+r,this.g=+g,this.b=+b},HSL=function(h,s,l){this.h=+h,this.s=+s,this.l=+l},CMYK=function(c,m,y,k){this.c=+c,this.m=+m,this.y=+y,this.k=+k},COLOR=function(o,t){this.rgb=new RGB(0,0,0),this.hsl=new HSL(0,0,0),this.cmyk=new CMYK(0,0,0,0),this.hex="000000",void 0===t?COLOR.hexReg.test(o)?t="hex":o instanceof RGB?t="rgb":COLOR.rgbReg.test(o)?t="rgbs":o instanceof HSL?t="hsl":COLOR.hslReg.test(o)?t="hsls":/[a-zA-z]+/.test(o)?t="word":"object"==typeof o&&(void 0!==o.r&&(t="rgb"),void 0!==o.h&&(t="hsl")):(this.setVal(t,o),this.updateVals(t))};COLOR.hexReg=/^#?[0-9a-fA-F]{3,6}/,COLOR.rgbReg=/^rgba?\((\d+),\s*(\d+),\s*(\d+)[,\d\.]*\)/,COLOR.hslReg=/^hsla?\((\d+),\s*(\d+)%,\s*(\d+)%[,\d\.]*\)/,COLOR.prototype.setVal=function(k,v){var reg;switch(k=k||"r"){case"r":case"g":case"b":this.rgb[k]=v,k="rgb";break;case"rgb":Object.assign(this.rgb,v);break;case"rgbs":reg=COLOR.rgbReg.exec(v),Object.assign(this.rgb,new RGB(reg[1],reg[2],reg[3])),k="rgb";break;case"h":case"s":case"l":this.hsl[k]=v,k="hsl";break;case"hsl":Object.assign(this.hsl,v);break;case"hsls":reg=COLOR.hslReg.exec(v),Object.assign(this.hsl,new HSL(reg[1],reg[2],reg[3])),k="hsl";break;case"c":case"m":case"y":case"k":this.cmyk[k]=v,k="cmyk";break;case"cmyk":Object.assign(this.cmyk,v);break;case"hex":v="#"==v[0]?v.substr(1):v,this.hex=3==v.length?v[0]+v[0]+v[1]+v[1]+v[2]+v[2]:v;break;case"word":this.hex=this.wordToHex(v),k="hex"}return this.updateVals(k),this},COLOR.prototype.updateVals=function(k){switch(k){case"rgb":this.rgbToHsl().rgbToCmyk().rgbToHex();break;case"hsl":this.hslToRgb().rgbToCmyk().rgbToHex();break;case"cmyk":this.cmykToRgb().rgbToHsl().rgbToHex();break;case"hex":this.hexToRgb().rgbToHsl().rgbToCmyk()}return this},COLOR.prototype.rgbToHsl=function(){var h,s,r=this.rgb.r/255,g=this.rgb.g/255,b=this.rgb.b/255,max=Math.max(r,g,b),min=Math.min(r,g,b),l=(max+min)/2;if(max==min)h=s=0;else{var d=max-min;switch(s=l>.5?d/(2-max-min):d/(max+min),max){case r:h=(g-b)/d+(g<b?6:0);break;case g:h=(b-r)/d+2;break;case b:h=(r-g)/d+4}h/=6}return this.hsl.h=360*h,this.hsl.s=100*s,this.hsl.l=100*l,this},COLOR.prototype.rgbToCmyk=function(){var r=this.rgb.r/255,g=this.rgb.g/255,b=this.rgb.b/255,k=Math.min(1-r,1-g,1-b),c=(1-r-k)/(1-k),m=(1-g-k)/(1-k),y=(1-b-k)/(1-k);return this.cmyk.c=255*c||0,this.cmyk.m=255*m||0,this.cmyk.y=255*y||0,this.cmyk.k=255*k,this},COLOR.prototype.rgbToHex=function(){return this.hex=("0"+Math.round(this.rgb.r).toString(16)).substr(-2)+("0"+Math.round(this.rgb.g).toString(16)).substr(-2)+("0"+Math.round(this.rgb.b).toString(16)).substr(-2),this},COLOR.prototype.hslToRgb=function(){var r,g,b,h=this.hsl.h/360,s=this.hsl.s/100,l=this.hsl.l/100;if(0==s)r=g=b=l;else{var q=l<.5?l*(1+s):l+s-l*s,p=2*l-q;r=this.hue2rgb(p,q,h+1/3),g=this.hue2rgb(p,q,h),b=this.hue2rgb(p,q,h-1/3)}return this.rgb.r=255*r,this.rgb.g=255*g,this.rgb.b=255*b,this},COLOR.prototype.wordToHex=function(str){var ctx=document.createElement("canvas").getContext("2d");return ctx.fillStyle=str,ctx.fillStyle.substr(1)},COLOR.prototype.hue2rgb=function(p,q,t){return t<0&&(t+=1),t>1&&(t-=1),t<1/6?p+6*(q-p)*t:t<.5?q:t<2/3?p+(q-p)*(2/3-t)*6:p},COLOR.prototype.cmykToRgb=function(){var c=this.cmyk.c/100,m=this.cmyk.m/100,y=this.cmyk.y/100,k=this.cmyk.k/100,r=1-Math.min(1,c*(1-k)+k),g=1-Math.min(1,m*(1-k)+k),b=1-Math.min(1,y*(1-k)+k);return this.rgb.r=255*r,this.rgb.g=255*g,this.rgb.b=255*b,this},COLOR.prototype.hexToRgb=function(){return this.rgb.r=parseInt(this.hex.substr(0,2),16),this.rgb.g=parseInt(this.hex.substr(2,2),16),this.rgb.b=parseInt(this.hex.substr(4,2),16),this},COLOR.prototype.toString=function(type,alpha){switch(type){case"rgb":return`rgb(${Math.round(this.rgb.r)},${Math.round(this.rgb.g)},${Math.round(this.rgb.b)})`;case"rgba":return`rgba(${Math.round(this.rgb.r)},${Math.round(this.rgb.g)},${Math.round(this.rgb.b)},${alpha})`;case"rgbv":return`${Math.round(this.rgb.r)},${Math.round(this.rgb.g)},${Math.round(this.rgb.b)}`;case"hsl":return`hsl(${Math.round(this.hsl.h)},${Math.round(this.hsl.s)}%,${Math.round(this.hsl.l)}%)`;case"hsla":return`hsla(${Math.round(this.hsl.h)},${Math.round(this.hsl.s)}%,${Math.round(this.hsl.l)}%,${alpha})`;case"hslv":return`${Math.round(this.hsl.h)},${Math.round(this.hsl.s)}%,${Math.round(this.hsl.l)}%`;case"cmyk":return`cmyk(${Math.round(this.cmyk.c)},${Math.round(this.cmyk.m)},${Math.round(this.cmyk.y)},${Math.round(this.cmyk.k)})`;case"hex":return"#"+this.hex}};const evPoints=e=>"touch"!=e.type.substring(0,5)?[e]:e.touches.length?e.touches:e.changedTouches,getEXY=(e,o)=>{let rect=(o||e.target).getBoundingClientRect();return{x:e.pageX-rect.left,y:e.pageY-rect.top}},getEventXY=(e,o)=>getEXY(evPoints(e)[0],o),degreesToRadians=a=>a*Math.PI/180,radiansToDegrees=a=>180*a/Math.PI,angleFromPoints=(x1,y1,x2,y2)=>Math.atan2(y2-y1,x2-x1),pointDistance=(x1,y1,x2,y2)=>Math.hypot(x1-x2,y1-y2),angleFromSides=(a,b,c)=>Math.acos((c*c+a*a-b*b)/(2*c*a)),rand=(n,x)=>Math.round(Math.random()*(x-n))+n,circumference=r=>2*Math.PI*r,xy=(x,y)=>({x:x,y:y}),vxs=(x0,y0,x1,y1)=>x0*y1-x1*y0,bounce=(n,x)=>(p,s)=>p>=x||p<=n?-s:s,bounceX=a=>Math.sign(a)*unsignHalfRadian(-signHalfRadian(Math.abs(signRadian(a)))),bounceY=a=>-signRadian(a),ratio=(min,max)=>n=>n*min/max,nudge=(o,p,n)=>p*n+o,clamp=(min,max)=>n=>n>max?max:n<min?min:n,unsignNumber=max=>n=>n<0?n+max:n,unsignRadian=unsignNumber(2*Math.PI),unsignHalfRadian=unsignNumber(Math.PI),unsignDegree=unsignNumber(360),signNumber=max=>n=>n>.5*max?n-max:n<-.5*max?n+max:n,signRadian=signNumber(2*Math.PI),signHalfRadian=signNumber(Math.PI),signDegree=signNumber(360),wrapNumber=max=>{const t=unsignNumber(max),s=signNumber(max);return n=>t(s(n))},within=(min,max)=>{const r=max-min+1,t=unsignNumber(r),s=signNumber(r);return n=>t(s(n-min))+min},partof=(min,max)=>n=>(n-min)/(max-min),partofCircle=partof(0,360),toward=(min,max)=>n=>n*(max-min)+min,mapN=(min,max)=>{const t=toward(min,max);return(min,max)=>{const p=partof(min,max);return n=>t(p(n))}},mapRange=(n,min1,max1,min2,max2)=>toward(min2,max2)(partof(min1,max1)(n)),roundTo=(n,x)=>{if(x<1){var m=(""+x).split("."),m2=Math.pow(10,m[1].length);n*=m2,x*=m2}let r=x*Math.round(n/x);return m2?r/m2:r},positionToward=(x1,y1,x2,y2,p)=>xy(toward(x1,x2)(p),toward(y1,y2)(p)),getSatelliteXY=(x,y,a,d)=>({x:x+Math.cos(a)*d,y:y+Math.sin(a)*d}),overlap=(a1,a2,b1,b2)=>Math.min(a1,a2)<=Math.max(b1,b2)&&Math.min(b1,b2)<=Math.max(a1,a2),intersectBox=(x0,y0,x1,y1,x2,y2,x3,y3)=>overlap(x0,x1,x2,x3)&&overlap(y0,y1,y2,y3),pointSide=(px,py,x0,y0,x1,y1)=>vxs(x1-x0,y1-y0,px-x0,py-y0),intersect=(x0,y0,x1,y1,x2,y2,x3,y3)=>xy(vxs(vxs(x0,y0,x1,y1),x0-x1,vxs(x2,y2,x3,y3),x2-x3)/vxs(x0-x1,y0-y1,x2-x3,y2-y3),vxs(vxs(x0,y0,x1,y1),y0-y1,vxs(x2,y2,x3,y3),y2-y3)/vxs(x0-x1,y0-y1,x2-x3,y2-y3)),isIntersect=(x0,y0,x1,y1,x2,y2,x3,y3)=>IntersectBox(x0,y0,x1,y1,x2,y2,x3,y3)&&2!=Math.abs(PointSide(x2,y2,x0,y0,x1,y1)+PointSide(x3,y3,x0,y0,x1,y1))&&2!=Math.abs(PointSide(x0,y0,x2,y2,x3,y3)+PointSide(x1,y1,x2,y2,x3,y3)),pointInRect=(x1,y1,x2,y2)=>(px,py)=>px>=x1&&px<=x2&&py>=y1&&py<=y2,inRange=(a,b)=>n=>a<=n&&b>=n,pointInArc=(px,py,ax,ay,ir,or,as,ae)=>inRange(as,ae)(Math.atan2(ay-py,ax-px))&&inRange(ir,or)(Math.hypot(px-ax,py-ay)),rectInRect=(x1,y1,x2,y2)=>{const r=pointInRect(x1,y1,x2,y2);return(x1,y1,x2,y2)=>r(x1,y1)&&r(x2,y2)},circleCollission=(x1,y1,r1,x2,y2,r2)=>pointDistance(x1,y1,x2,y2)<r1+r2;
//# sourceMappingURL=tools/src/drawtools.min.js.map