const pathmaker={start(ctx){ctx.beginPath()},end(ctx){ctx.closePath()},point(ctx,pts){if(pts.length<2)return!1;ctx.moveTo(pts[0].x,pts[0].y);for(let i in pts)ctx.lineTo(pts[i].x,pts[i].y)},polygon(ctx,x,y,r,a,s){let eachangle=360/s,line=[];for(let i=0;i<=s;i++)line.push(getSatelliteXY({x:x,y:y},a+eachangle*i,r));pathmaker.points(ctx,line)},circle(ctx,x,y,r,a1,a2,a3){pathmaker.arc(ctx,x,y,r,void 0!==a1?a1:0,void 0!==a2?a2:2*Math.PI,void 0!==a3?a3:void 0)},arc(ctx,x,y,r,a1,a2,a3){ctx.arc(x,y,r,a1,a2,a3)},rect(ctx,x,y,w,h){pathmaker.points(ctx,[{x:x,y:y},{x:x+w,y:y},{x:x+w,y:y+h},{x:x,y:y+h},{x:x,y:y}])},pie(ctx,x,y,or,ir,sa,ea,ad){pathmaker.arc(ctx,x,y,or,sa,ea+sa,!ad),pathmaker.arc(ctx,x,y,ir,ea+sa,sa,ad)},roundRect(ctx,x,y,w,h,r){r=void 0===r?0:"number"==typeof r?{tl:r,tr:r,br:r,bl:r}:Object.assign({tl:0,tr:0,br:0,bl:0},r),ctx.moveTo(x+r.tl,y),ctx.lineTo(x+w-r.tr,y),ctx.quadraticCurveTo(x+w,y,x+w,y+r.tr),ctx.lineTo(x+w,y+h-r.br),ctx.quadraticCurveTo(x+w,y+h,x+w-r.br,y+h),ctx.lineTo(x+r.bl,y+h),ctx.quadraticCurveTo(x,y+h,x,y+h-r.bl),ctx.lineTo(x,y+r.tl),ctx.quadraticCurveTo(x,y,x+r.tl,y)}},makePath=(ctx,paths)=>{pathmaker.start(ctx);for(let o of paths)pathmaker[o.splice(0,1,ctx)[0]].apply(null,o);pathmaker.end(ctx)},strokeIt=(ctx,options)=>{options&&options.lineWidth&&Object.assign(ctx,options).stroke()},fillIt=(ctx,options)=>{options&&options.fillStyle&&Object.assign(ctx,options).fill()},drawCircle=(ctx,x,y,r,options)=>{makePath(ctx,[["circle",x,y,r]]),fillIt(ctx,options),strokeIt(ctx,options)},drawRect=(ctx,x,y,w,h,options)=>{makePath(ctx,[["rect",x,y,w,h]]),fillIt(ctx,options),strokeIt(ctx,options)},drawPolygon=drawShape=((ctx,x,y,r,a,s,options)=>{makePath(ctx,[["polygon",x,y,r,a,s]]),fillIt(ctx,options),strokeIt(ctx,options)}),drawRandomRect=(ctx,x,y,w,h,options)=>{options.fillStyle="rgba("+rand(120,250)+","+rand(120,250)+","+rand(120,250)+","+(options&&void 0!==options.opacity?options.opacity:.7)+")",drawRect(ctx,x,y,w,h,options)},drawSegment=(ctx,x1,y1,x2,y2,options)=>{makePath(ctx,[["points",[{x:x1,y:y1},{x:x2,y:y2}]]]),strokeIt(ctx,options)},drawLine=(ctx,line,options)=>{makePath(ctx,[["points",line]]),strokeIt(ctx,options),fillIt(ctx,options)},drawableImage=url=>{let loaded=!1,i=new Image;i.onload=(()=>loaded=!0),i.src=url;const drawI=function(ctx,x,y,w,h){loaded?ctx.drawImage(i,x,y,w,h):setTimeout(drawI,10)};return drawI},drawText=(ctx,text,x,y,options)=>{options.lineWidth&&Object.assign(ctx,options).strokeText(text,x,y),options.fillStyle&&Object.assign(ctx,options).fillText(text,x,y)},drawParagraph=(ctx,text,x,y,lineHeight,options)=>{var ps=text.split(/\n/);for(var i in ps)drawText(ctx,ps[i],x,y+lineHeight*i,options)},drawLabel=(ctx,text,x,y,options)=>{(ctx=Object.assign(ctx,options)).globalCompositeOperation="destination-out",ctx.strokeText(text,x,y),ctx.globalCompositeOperation="source-over",ctx.fillText(text,x,y)},drawPulse=(ctx,x,y,outerRadius,innerRadius,options)=>{drawCircle(ctx,x,y,outerRadius,options),ctx.globalCompositeOperation="destination-out",drawCircle(ctx,x,y,innerRadius,options),ctx.globalCompositeOperation="source-over"},drawPie=(ctx,x,y,outerRadius,innerRadius,startangle,endangle,additive,options)=>{makePath(ctx,[["pie",x,y,outerRadius,innerRadius,startangle,endangle,additive]]),fillIt(ctx,options),strokeIt(ctx,options)},drawRoundRect=(ctx,x,y,w,h,r,options)=>{makePath(ctx,[["roundRect",x,y,w,h,r]]),strokeIt(ctx,options),fillIt(ctx,options)},drawGradient=(ctx,direction,stops,position)=>{let grd=ctx.createLinearGradient.apply(ctx,direction);for(let i in stops)grd.addColorStop.apply(grd,stops[i]);ctx.fillStyle=grd,ctx.fillRect.apply(ctx,position)},drawPoints=(ctx,line,radius,options)=>{pathmaker.start(ctx);for(let i in line)pathmaker.circle(ctx,line[i].x,line[i].y,radius);pathmaker.end(ctx),strokeIt(ctx,options),fillIt(ctx,options)},drawGrid=(ctx,rows,cols,x,y,w,h,options)=>{pathmaker.start(ctx);for(let i=0;i<=rows;i++)pathmaker.points(ctx,[{x:x,y:h*(i/rows)+y},{x:x+w,y:h*(i/rows)+y}]);for(let i=0;i<=cols;i++)pathmaker.points(ctx,[{x:w*(i/cols)+x,y:y},{x:w*(i/cols)+x,y:y+h}]);pathmaker.end(ctx),strokeIt(ctx,options),fillIt(ctx,options)},drawLineGraph=(ctx,line,x,y,w,h)=>{drawGrid(ctx,3,5,x,y,w,h,{strokeStyle:"#ddd",lineWidth:2,lineJoin:"round",lineCap:"round"}),drawLine(ctx,line,{strokeStyle:"black",lineWidth:6,lineJoin:"round",lineCap:"round"}),drawPoints(ctx,line,6,{fillStyle:"white",strokeStyle:"black",lineWidth:4})},rotateAndDo=(ctx,angleInRad,positionX,positionY,callback)=>{ctx.translate(positionX,positionY),ctx.rotate(angleInRad),callback(),ctx.rotate(-angleInRad),ctx.translate(-positionX,-positionY)},translateScaleRotate=(ctx,x,y,sx,sy,r,fn)=>{ctx.save(),ctx.translate(x,y),ctx.scale(sx,sy),ctx.rotate(r),fn(),ctx.restore()},translateScale=(ctx,x,y,sx,sy,fn)=>{ctx.save(),ctx.translate(x,y),ctx.scale(sx,sy),fn(),ctx.restore()},drawImageTSR=(ctx,img,x,y,w,h,sx,sy,r)=>{translateScaleRotate(ctx,x,y,sx,sy,r,function(){ctx.drawImage(img,.5*-w,.5*-h,w,h)})},storeImage=(cvs,w,h)=>{let i=new Image;return i.src=cvs.toDataURL(),i};